#!/usr/bin/python
# -*- coding: utf-8 -*-

import MySQLdb 
import sys
import smtplib



class db:
    sql=""
    def __init__(self):
	self.sql="select "

    def select(self,what):
	self.sql+=str(what)+" "
	
    def fromm(self,table):
	self.sql+="from "+str(table)+" "

    def where(self,cond):
	self.sql+="where ("+str(cond)+");"
	
    def leftjoin(self,ljoin,on):
	self.sql+="left join " +str(ljoin)+" on "+str(on)+" "
	
    
    def dbconnect(self):
	res=0
	try:
		db = MySQLdb.connect(host="localhost", user="root", passwd="w@rE^tmn02", db="redmine", charset='utf8')
		cursor = db.cursor()
		res=(cursor,db)
	except MySQLdb.Error, e:
		print "Error "+str(e.args[0])+str(e.args[1])
		res=0		
	finally:		
		return res
	return res

    def get(self):
	res=[]
	(c,d)=self.dbconnect()
	print self.sql
	c.execute(self.sql)
	numrows=int(c.rowcount)
	for i in xrange(numrows):
	    res.append(c.fetchone()[0])
	d.close()
	return res
    def getall(self):
	res=[]
	(c,d)=self.dbconnect()
	c.execute(self.sql)
	res=c.fetchall()
	d.close()
	return res
	
	
    

def get_title_by_id(id):
    rdb=db()
    rdb.select("subject")
    rdb.fromm("issues")
    rdb.where("id="+id.as_string())
    title=rdb.get()
    return title

#def get_performer_by_issue_id(id)
#    rdb=db()
#    rdb.select("")




####################################################################################
#Ужасно оформленная работа с базой. Просто набор процедур: собираем айдишники задач до окончанияк которых 3 дня
#(по умолчанию) по ним собираем айдишники наблюдателей, автор и исполнителей. Исполнителей прогоняем по
#выбирателю маилов груп. Остальных сморти собиратель маилов пользователей

#select issues.id, custom_values.customized_id, custom_values.value, custom_values.custom_field_id from issues left join custom_values on issues.id=custom_values.customized_id where (custom_values.custom_field_id=2 and DATEDIFF(custom_values.value,CURDATE())>0 and DATEDIFF(custom_values.value,CURDATE())<=3);
#return all issues wich should be closed soon or exceeded 
def getissuesid(days):
    rdb=db()
    id_issues=[]
    rdb.select("issues.id, custom_values.customized_id, custom_values.value, custom_values.custom_field_id")
    rdb.fromm("issues")
    rdb.leftjoin("custom_values","issues.id=custom_values.customized_id")
    rdb.where("DATEDIFF(custom_values.value,CURDATE())>=0 and DATEDIFF(custom_values.value,CURDATE())<="+str(days)+" and custom_values.custom_field_id=2")
    id_issues=rdb.get()
    print id_issues
    return id_issues
	
	
#we get dictionary {id_issue - [list of users id who are watchers]}	
def getwatchers(issues):
    res={}
    for t in issues:
	rdb=db()
	rdb.select("users.mail")
	rdb.fromm("users")
	rdb.leftjoin("watchers","users.id=watchers.user_id")
	rdb.where("watchers.watchable_type='Issue' and watchers.watchable_id="+str(int(t)))
	res[t]=rdb.get()
    return res



#get all groups id
def getgroupsid():
    rdb=db()
    rdb.select("id")
    rdb.fromm("users")
    rdb.where("type='Group'")
    res=rdb.get()
    return res

	

	
#id = list of users_id where type=group
#{id_group:[mails]}
DODELAT VIBORKU GRUP
def getgroupmails(id):
    mails={}
    groups=getgroupsid()
    for k,g in id.iteritems():	
	if g in groups:
	    rdb=db()
	    rdb.select("users.mail")
	    rdb.leftjoin("groups_users","group_id="+str(g)+" where id=user_id;")
	    mails[k]=rdb.get()
    return mails




#get users id from issues
#{id_issue:[id_users]}

def getusersid(issues):
    performers={}
    id_users={}
    for i in issues:
	rdb=db()
	rdb.select("author_id,assigned_to_id")
	rdb.fromm("issues")
	rdb.where("id="+str(i))
	data=rdb.getall()
	for rec in data:
		auth,perf = rec
		id_users[i]=auth
		#append to list to check if performer is group later
		performers[i]=perf	
	return (id_users,performers)


def getsimplemails(id):
    rdb=db()
    rdb.select("mail")
    rdb.fromm("users")
    rdb.where("id="+str(id))
    return rdb.get()

#get users mails in dictionary [id user mail]	
#id_users={id_issue:id_user}
def getusersmails(id_users):
    list=[]
    mails={}
    gmail=getgroupsid()
    for k,id in id_users.iteritems():
	#if we've got plain dictionary
	if type(id)!=type(list):
		if id not in gmail:
			mails[k]=getsimplemails(id)
	#if we ve got lists by indexes(like watchers output)
	else:
		list=[]
		for i in id:
			list.append(getsimplemails(id))
		mails[k]=list
    return mails
    


###########################################################################


##########################################################################
#Send Email as HTTP
#	

#reminders={id_issue:[mails of issue envolved units]}
def sendmail(reminders):	
	for isid,mails in reminders.iteritems():
		print mails
		from email.MIMEText import MIMEText
		textsubtype="plain"
		#message = "Attention! One of your tasks soon should be closed. Please look at the issue: http://redmine.tmn.transneft.ru/redmine/issues/"+str(isid)
		message = "Внимание! Одна из ваших задач скоро должна быть закрыта или уже просрочена. Пожалуйста, посмотрите: http://redmine.tmn.transneft.ru/redmine/issues/"+str(isid)
		msg=MIMEText(message,textsubtype,'UTF-8')
		for m in mails:
		    msg['To']=','.join(m)
		msg['Subject']="Напоминание о задаче"
		print msg.as_string()
		try:
		    smtpObj = smtplib.SMTP('10.81.1.12')
		    print msg
		    smtpObj.sendmail('redmine@tmn.transneft.ru', mails, msg.as_string())
		    print "Successfully sent email"+msg.as_string()
		except Exception, exc:
			print "Error: unable to send email due to "+str(exc)
		finally:
			smtpObj.quit()

#############################################################

   
def main():
	#get issues ids, default 3 days
	issues=getissuesid(3)
	
#	issues=checkclosed(issues)
	
	#get watchers of issues {id_issue:[mail],...}
	watchers=getwatchers(issues)
	
	#get all user's ids
	#{id_issue:[users_id]}
	(users,performers)=getusersid(issues)
	
	#get mails of groups if performer id is group
	#if not - we'll get empty set
	#format {issue_id:[mails]}
	#for k,v in performers.iteritems():
	gmails=getgroupmails(performers)
	
	#get users-performers mails
	#for k,v in performers.iteritems():
	pmails=getusersmails(performers)
	#get mails of authors(100% users)
	#format {id_issue:{id_group:[mails]}}
	#for k,v in users.iteritems():
	amails=getusersmails(users)
	
	
	
	reminders={}
	empty={}
	#get all mails from all arrays in emty then delete duplicate and write in result
	for k,v in amails.iteritems():
    	    if not empty.has_key(k):
		empty[k]=[]
	    empty[k].append(v)
	for k,v in pmails.iteritems():
	    if not empty.has_key(k):
		empty[k]=[]
	    empty[k].append(v)
	for k,v in watchers.iteritems():
	    if not empty.has_key(k):
		empty[k]=[]
	    for i in v:
		empty[k].append(i)
	for k,v in gmails.iteritems():
	    if not empty.has_key(k):
		empty[k]=[]
	    for i in v:
		empty[k].append(i)
	result={}
	for k,v in empty.iteritems():
	    temp=[]
	    for i in v:
		if i not in temp:
			temp.append(i)
	    result[k]=temp
	
	print "result="
	print result
	sendmail(result)
	
	
main()
